**参考**

[计算机/软工408考研--数据结构重难点](https://zhuanlan.zhihu.com/p/165229143)

[计算机/软工408考研---组成原理+OS重难点](https://zhuanlan.zhihu.com/p/194156185)

[计算机/软工408考研---计算机网络重难点](https://zhuanlan.zhihu.com/p/187130615)



[408数据结构——绪论&复杂度分析](https://blog.csdn.net/qq_21457395/article/details/120381958)

[冷月手撕408之数据结构(1)-导论](https://cloud.tencent.com/developer/article/1790830)

[数据结构线性表（王道随书408考研）](https://www.codeleading.com/article/21576059920/)

[408数据结构——线性表](https://blog.csdn.net/qq_21457395/article/details/121326143)

参考：https://juejin.cn/user/606586151647870/posts





# 408考察方式

​		计算机基础综合408，主要通过**选择题(40题，每题2分，共80分)**和**大题(7题，每题分数不等，共70分)**进行考察，一共包含4门学科--数据结构45'、组成原理45'、操作系统35'、计算机网络25'，其中数据结构和组成原理考察的总分值较高，操作系统其次，计算机网络总分值最低。



# 《数据结构》

408真题中，数据结构考察包含如下形式和特点：

**选择题部分：**共11题22分，主要考察对数据结构的细节理解，很多题目并不是简单考察某个结构/算法的最终结果，大都考察结构/算法的中间过程。同时选择题会挖很多坑，一般感觉一眼就能看出答案的反而需要重视，一不小心就入坑。

**大题目部分：**共2题22-25分左右，2个大题分为**算法大题**和**应用大题**。其中算法大题主要考察算法思想、伪代码编写、分析时间空间复杂度，集中考察线性表和[二叉树](https://www.zhihu.com/search?q=二叉树&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})的算法；应用大题需要结合结构/算法针对题目来解答，主要以文字+分析+图表的形式作答。



# 第一章：绪论

![](media_Guide/数据结构三要素.png)

**存储结构**

- 顺序存储：逻辑上连续，物理上也连续
- 链式存储：逻辑上连续，物理不一定也连续
- 索引存储：建立一张索引表，搜索时先查表
- 散列存储：哈希存储

![](media_Guide/算法.png)

在绪论中，理解算法的评价标准。时间复杂度和空间复杂度。时间复杂度要知道怎么计算的。



## 考点1. 时间复杂度和空间复杂度

- 时间复杂度（选+算第3问）

    > 非递归函数
    >
    > 1. 利用累加/累乘法分析非递归函数的时间复杂度；
    >
    > **递归函数**
    >
    > 1. 利用Master公式分析满足T(n)=aT(n/b)+n^d的递归函数的时间复杂度，例如：快速排序；--- **Master公式适用于递归分治算法**
    > 2. 利用依次递归的方式分析普通递归函数的时间复杂度；
    > 3. 利用特例法分析非常规递归函数的时间复杂度，如：分析斐波那契数列的递归函数的时间复杂度，举特例F(5)来分析；

- [空间复杂度](https://www.zhihu.com/search?q=空间复杂度&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})（选择题+算法大题第3问）

    > 1. 空间复杂度与时间复杂度分析大致相同，只是空间复杂度的侧重点在额外的空间上；
    > 2. **需要注意的是递归函数有递归栈这个特殊的额外空间**



# 第二章：线性表

**线性表(Linear List)**是具有<u>**相同数据类型**</u>的n(n>=0)个**数据元素**的**有限**序列，当表长n为0的时候，为空表。

- 除第一个元素外，每个元素有且只有一个直接前驱。
- 除最后一个元素外，每个元素有且只有一个直接后续。

**注意：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构**。两者属于不同层面的概念，因此不要混淆。



**线性表的基本操作 — 创销增删改查**

```
// 创建、销毁
InitList(&L): 初始化表，构造空的线性表L，分配内存空间。
DestroyList(&L): 销毁操作，释放线性表L所占空间。
// 增删
ListInsert(&L, i, e): 插入操作
ListDelete(&L, i, &e): 删除操作，删除表L中第i个位置元素，并用e返回删除的元素的值。
// 查
LocateElem(L, e): 按值查找
GetElem(L, i): 按位查找
// 其他
Length(L): 求表长
PrintList(L): 输出操作，按前后顺序输出表L所有元素值。
Empty(L): 判空操作，若表L为空表，则返回true，否则返回false。

【注意】传入参数的&：表示参数修改的结果需要带回来。
```

**位序**：线性表中元素的位序是从 1 开始的，而数组中的元素下标是从 0 开始的，这个非常重要，应用时需区分清楚。

![](media_Guide/线性表.png)

线性表分为**顺序表**和**链表**。

顺序表其实就可以理解为数组。逻辑上相邻的元素物理上也相邻。

链表分为单链表、双链表、循环链表、静态链表；

重要掌握链表的分类和插入、删除方法。逻辑上相邻的元素物理不一定上也相邻。



## 2.1.顺序表

* 顺序表就是数组；
* 线性表的顺序存储；
* 是用一组地址连续的存储单元依次存储线性表中的元素；

- 逻辑上相邻的两个元素在物理位置上也相邻。

![](media_Guide/顺序表（顺序存储）.png)

### 顺序表特点

1. 顺序表最主要的特点是**随机访问（随机存取），即通过首地址和元素序号可以在O(1)的时间内找到指定的元素。但插入和删除操作需要移动大量元素**。
2. 插入和删除操作需要移动大量元素；
3. 存储密度高，只存储数据，不存储指针；
4. 拓展容量不方便。



### 复杂度分析

* **顺序表插入操作：
    最好情况：在表尾插入，元素后移语句不执行，时间复杂度为O(1)
    最坏情况：在表头插入，元素后移语句将执行n次，时间复杂度为O(n)
    平均情况：平均时间复杂度为O(n)**

    ![](media_Guide/顺序表插入操作时间复杂度.png)

* **顺序表删除操作：
    最好情况：删除表尾元素，无需移动元素，时间复杂度为O(1)
    最坏情况：删除表头元素，需要移动除第一个元素外的所有元素，时间复杂度为O(n)
    平均情况：平均时间复杂度为O(n)**

    ![](media_Guide/顺序表删除操作时间复杂度.png)

* **顺序表按值查找（顺序查找）：
    最好情况：查找的元素就在表头，仅需比较一次，时间复杂度为O(1)
    最坏情况：查找的元素在表尾或不存在时，需要比较n次，时间复杂度为O(n)
    平均情况：平均时间复杂度为O(n)**

    ![](media_Guide/顺序表查找操作时间复杂度.png)



### 基本代码

```C
// 如何一个数据元素的大小？
sizeof(ElemType)
```

```C
#include <stdio.h>
#include <stdlib.h>

// 宏定义
#define MAXSIZE 10      //定义最大长度
#define ElemType int    //定义顺序表存储的类型，可自行设置

//========================== 初始化 InitList 静态数组 ==========================

// 顺序存储结构的线性表的类型
typedef struct {
    ElemType data[MAXSIZE]; //用『静态数组』存放数据元素
    int length;             //顺序表的当前长度
}SqList;                    //顺序表的类型定义（静态分配方式） Sq:Sequence 顺序、序列

// 顺序表初始化一：静态数组
SqList InitList() {
    SqList L;
    L.length = 0;
    return L;
}

// 顺序表初始化二：静态数组
// C语言中是不存在引用传参，仅仅是取地址符。所以GCC编译不过。
// 解决方案:
//      1.用指针传参代替引用传参（代码如下InitList_2_1）；
//      2.将代码保存成.cpp文件(c++中支持引用)。
void InitList_2(SqList &L) {
    for (int i = 0; i < MAXSIZE; i++) {
        L.data[i] = 0;
    }
    L.length = 0;
}

// 指针传参：静态数组
void InitList_2_1(SqList *L) {
    for (int i = 0; i < MAXSIZE; i++) {
        L->data[i] = 0;    //赋默认值，否则会有脏数据
    }
    L->length = 0;
}

//========================== 初始化 InitList 动态数组 ==========================

typedef struct{
    ElemType *data;     //动态分配数组的指针
    int maxSize;        //顺序表最大容量
    int length;         //顺序表当前长度
}SeqList;               //顺序表的类型定义（动态分配方式）

// 顺序表初始化三：动态分配数组
void InitList_3(SeqList *L) {
    L->data = (ElemType *)malloc(MAXSIZE * sizeof(ElemType));
    L->length = 0;
    L->maxSize = MAXSIZE;
}

void IncreaseSize(SeqList &L, int len) {
    ElemType *p = L.data;
    L.data = (ElemType *)malloc((L.maxSize + len) * sizeof(ElemType));
    for (int i = 0; i < L.length; i++) {
        L.data[i] = p[i];           //将数据复制到新区域
    }
    L.maxSize = L.maxSize + len;    //顺序表最大长度增加len
    free(p);                        //是否原内存空间
}

//========================== 插入 ==========================
/*	
 * 在顺序表 L LL 的第 i ii (1<=i<=L.length+1)个位置上插入新元素 e
 * 判断 i 的位置是否合法
 * 第 i 个元素及气候依次从后移动一个位置
 * 顺序表长度 加1
 */
bool ListInsert(SqList &L, int i, ElemType e) {
    if (i <= 0 || i > L.length + 1) { // 插入位置是否合法
        return false;
    }
    if (L.length >= MAXSIZE) {     // 空间是否已满
        return false;
    }
    for (int j = L.length; i >= j ; j--) {
        L.data[j] = L.data[j-1];    // 将第i个元素及之后的元素向后移动
    }
    L.data[i-1] = e;    // 在位置i处插入e
    L.length++;         // 线性表长度 +1
    return true;
}

//========================== 删除 ==========================

/*
 * 删除顺序表 L LL 中的第 i ii（1<=i<=L.length） 个位置,用引用变量 e ee 返回
 * 判断 i ii 的位置是否合法，否则返回false
 * 合法则将被删除元素赋予引用变量 e,把i+1个元素及其后的所有元素往前移动一个位置，返回true
 */
bool ListDelete(SqList &L, int i, ElemType &e) {
    if (i <= 0 || i > L.length) {
        return false;
    }

    e = L.data[i - 1];   //将被删除的元素赋予e

    for (int j = i; j < L.length; j++) {
        L.data[j - 1] = L.data[j]; 
    }
    
    L.length--;
    return true;
}

//========================== main ==========================

int main() {
    // 方式一
    SqList L1 = InitList();
  
    // 方式二
    SqList L2;          // 声明一个线性表
    InitList_2(L2);     // 初始化该线性表
    InitList_2_1(&L2);  // 初始化该线性表
    
    // 方式三
    SeqList L3;
    InitList_3(&L3);
    printf("L3最大长度为 %d a",L3.maxSize);
    // 动态扩大空间
    IncreaseSize(L3, 12);
    printf("\nL3动态增加空间后的最大长度为 %d a",L3.maxSize);
    
    return 0;
}
```



## 2.2.链表



### 单链表

```C
// 单链表节点
typedef struct LNode{	//节点类型
	ElemType data;	//数据域
	Struct LNode *next;	//指针域
}LNode;
```

### 创建单链表

**头插法建立单链表**

![](media_Guide/单链表头插法.png)

* 采用头插法建立单链表时，读入数据的顺序与生成的链表的元素顺序是相反的
* 从一个`空表`开始，通过`头插法`建立单链表的结点，以插入S所指的结点为例
* ① 先将 **S** 所指结点的`next`指针，指向 **L** 所指的头结点的`next`指针，保存了**头结点**的后继结点的地址
* ② 然后将**L**所指的头结点的`next`指针指向**S**所指的结点

> 每个结点的插入时间为 O(1)，设单链表长为 n，则总时间复杂度为 O ( n ) O(n)*O*(*n*)

```C
LinkList List_HeadInsert(LinkList &L)	//逆向建立单链表
	LNode *s;int x;
	L=(Linklist)malloc(sizeof(LNode));	//创建头结点
	L->next=NULL；	//初始为空链表
	
	scanf("%d",&x);	//输入结点的值
	while(x!=10){	//输入10表示结束
		s=(LNode*)malloc(sizeof(LNode));	//创建新结点
		s->data=x;
		s->next=L->next;
		L->next=s;	//将新结点插入表中，L为头指针
		scanf("%d",&x);
	}
	return L;
}	
```



**尾插法建立单链表**



**按序号查找**



**按值查找**



**插入结点操作**



**删除结点操作**



### 双链表

**双链表的插入**



#### 循环链表





## 2.3.顺序表和链表的比较

**1.存取方式**

```
顺序表：顺序存取，随机存取
链表：从头顺序存取
比如从第i个位置执行存或取的操作，顺序表仅需访问一次，链表需要从表头开始访问i次
```

**2.逻辑结构与物理结构**

```
顺序存储：逻辑上相邻的元素，对应的物理存储位置也相邻
链式存储：逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示的
```

**3.查找、插入和删除操作**

```
对于按值查找，顺序表无序时，两者的时间复杂度均为O(n),顺序表有序时采用折半查找，
时间复杂度为O(logn)

对于按序号查找，顺序表支持随机访问,时间复杂度仅为O(1),链表的平均复杂度为O(n)

顺序表的插入、删除操作，平均需要移动半个表长的元素，链表的插入删除只需修改相关指针域
由于链表的每个结点带有指针域，故存储密度<1
1234567
```

**4.空间分配**

```
顺序存储:
①一旦存储空间装满就不能扩充，若加入新元素，会发生内存溢出，也因此需要预先分配足够大的存储空间
②预先分配过大，浪费内存，预先分配过小，内存溢出
③动态分配内存虽然存储空间可以扩充，但是需要移动大量元素，导致操作效率低
④若是内存没有更大块的连续存储空间，会导致分配失败

链式存储
只在需要时分配结点空间，只要内存有空间就可以分配，操作灵活，高效
```





## 考点2. 线性表

- 顺序表(数组)（算）

    > **插入：**先确定插入点是否合法，然后再将插入点之后的元素都**后移一位**，最后插入
    > **删除：**先确定删除点是否合法，然后再将删除点元素删除，最后将删除点之后的元素**前移一位**
    > 查找：按索引下标查找O(1)；按值查找O(n)

* 链表（选+算）

    > 单链表
    >
    > 1. 头插法、尾插法
    > 2. 删除结点
    > 3. **两种特殊处理\*：**(1)对p结点进行前插操作；(2)删除p结点;
    >
    > 双链表
    >
    > 1. 类似单链表的头插法、尾插法
    > 2. 类似单链表的删除结点
    >
    > 循环单链表：类似单链表
    >
    > 循环双链表：类似双链表
    >
    > **[静态链表](https://www.zhihu.com/search?q=静态链表&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})\*：**利用数组结构来存储链表，起点为0，终点为-1
    >
    > **注意：**对链表结构的插入和删除操作常考选择题，链表要注意**头结点**这个概念。



# 第三章：栈与队列

## 栈

### 基本概念

> 只能在一端进行插入和删除的线性表。重点掌握顺序栈的结构。
>
> 栈的操作特性可以概括为：**后进先出（LIFO）**



### 应用



【题型】：给出入栈序列，**推导出栈序列个数，或者与队列结合**。

> n个不同元素进栈，有种不同的出栈排列？





## 队列





## 考点3. 栈和队列

- 栈（选）

> 1.顺序栈的top指针特点（区分队列的rear指针）
> 2.一串数列通过栈来处理能获得新序列的数量（Catlan公式）和可能得到的新序列
> 2.栈在括号匹配上的应用
> **3.栈在中缀表达式与后缀表达式的相互转换的应用\*(熟练掌握转换的中间过程)**

- 队列（选）

> 1.顺序队列的rear指针的特点
> **2.顺序循环队列判空判满的条件\*：(1)牺牲空间法；(2)size法；(3)tag标记法**
> **3.栈在二叉树层次遍历中的应用\*（变形：利用标记法来辅助确定出当前结点位于那一层）**

- 矩阵压缩存储（选）

> \1. 矩阵的压缩存储是套路题，做法如下：
> (1)看题，分析是按行存储还是按列存储
> (2)找出等差/等比规律
> (3)求[等差数列](https://www.zhihu.com/search?q=等差数列&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})/等比数列和，确定出压缩公式
> \2. 稀疏矩阵的存取方式：三元组、[十字链表](https://www.zhihu.com/search?q=十字链表&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})、行逻辑链接顺序表









### **树**

树重点掌握二叉树的性质，和二叉树的顺序存储和链式存储。以及线索二叉树。树的三种遍历也是经常考。在树的应用中，掌握二叉树排序树、二叉树平衡树、哈夫曼树。

### **图**

图中，一定要搞清楚图的基本术语，因为图的术语有很多。无向图和有向图都不一样。

其中掌握图的顺序存储和链式存储；图的遍历经常考，DFS、BFS；

图的应用一定要会手动的模拟，写不出算法没有关系。最小生成树、最短路径、拓扑排序、关键路径。

### **查找**

查找是基于排序的，有些乱序的序列需要先排好序后再查找。其中折半查找和查找树以及散列查找，hash函数经常考。

KMP算法 明白原理即可。

### **排序**

排序的算法很多，408要求主要掌握内部排序。重点搞清楚 交换排序 和选择排序，要明白各种排序的优势在哪儿和时间复杂度。







# 《数据结构》考点

### 2.4 树和二叉树

- 树和二叉树的基本概念（选）

> 1.树的性质：区分树的度和图的度
> 2.二叉树的性质：
> （1）n0 = n2 +1;
> （2）完全二叉树i结点的左孩子为2i，右孩子为2i+1 (从1开始编号)

- 二叉树的存储方式（选）

> \1. 顺序存储，其实就是按照完全二叉树来存储
> \2. 链表存储：链表的空指针数 = 结点数n + 1

- 二叉树的遍历方式（选+算）

> 四种遍历方式（先序，中序，后序，层次）
> 其中先序中序后序不仅要掌握递归方式还要掌握非递归方式，层次遍历需要借助队列来实现；**[线索二叉树](https://www.zhihu.com/search?q=线索二叉树&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})**是在先序中序后序递归实现方式上的变形（重点）

- 二叉树的应用（选+应）

> \1. 并查集：图里面最小生成树的基础
> \2. 二叉排序树(算)：代码模板记住
> 3.平衡二叉树AVL(选)：掌握LL型、RR型、LR型、RL型的调整过程
> 3.哈夫曼树和[哈夫曼编码](https://www.zhihu.com/search?q=哈夫曼编码&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})(选+应)：不仅会画图还要会用文字来叙述

### 2.5 图

- 图的概念（选）

> \1. 图的度与树的度的区分
> \2. [有向图](https://www.zhihu.com/search?q=有向图&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})与无向图的区分（连通性，强连通性）
> \3. 简单路径与简单回路
> \4. 距离：最短路径

- 图的存储方式（选+应一个小问）

> \1. [邻接矩阵](https://www.zhihu.com/search?q=邻接矩阵&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})*
> \2. 邻接表*
> \3. 十字链表(有向图)
> \4. 邻接多重表(无向图)

- 图的遍历方式（选+算）

> \1. BFS：类似二叉树的层次遍历；注意BFS的变形--求单源最短路径
> \2. DFS：类似二叉树的先序遍历；
> **3. BFS与DFS都需要借助辅助数组visited[]来标记当前结点是否被访问过**
> **4. 图的遍历与图的连通性的关系\***

- 图的应用（选+应）

> **1. 最小生成树**
> （1）prim算法
> （2）Kruskal算法
> **2. 最短路径**
> （1）dijkstra算法
> （2）Floyd算法
> **3. [拓扑排序](https://www.zhihu.com/search?q=拓扑排序&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})：**可以用来判断图是否有环
> **4.关键路径**

### 2.6 查找

- 顺序查找（选）

> \1. 普通顺序表：进行普通的从小到大的遍历查找插入点，然后**插入**
> **2. 有序顺序表\*：**进行二分的思想进行查找插入点，然后**插入 --- 记住二分思想的核心代码**
> 以上两种方式由于都需要进行插入，故时间复杂度为O(n^2)

- 分块查找（选）

> 使用了索引表+查找表的结构：
> （1）索引表：有序表 --- 二分查找
> （2）查找表 --- 根据索引分块后采用顺序查找方式查找

- 二叉排序树、AVL树(平衡二叉树)、B树、B+树（选）

> \1. 二叉排序树上的查找
> \2. AVL树上的查找：其实就等效为二叉排序树上的查找，因为AVL树就是一颗二叉排序树
> \3. B树：
> （1）概念：包含m/2向上取整-1 <= n(非根结点) <= m-1；[叶子结点](https://www.zhihu.com/search?q=叶子结点&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})不含数据，数据存在索引上等
> （2）B树高度求法：logm^(n+1) <= h <= logm/2向下取整^(n+1)/2 + 1
> （3）B树插入：可能使B树高度h+1
> （4）B树删除：可能使B树高度h-1
> \4. B+树
> （1）B+树的概念
> （2）B+树与B树的区别
> **（3）B+树的特点：**数据都存在叶子结点上，非终端结点只起索引作用；B+树可以有两种查询方式
> **注意：B/B+一般是以选择题的形式考察，并且考察的深度不高，我们只需要学习基本知识就可以**

- 散列表（选+应）

> \1. [散列函数](https://www.zhihu.com/search?q=散列函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})：直接定址法、除留取余法是重点，其他了解即可
> \2. 处理冲突：
> （1）开放定址法：线性探测法、平方探测法、再散列法是重点
> （2）拉链法
> \3. 装填因子
> **4. 求散列表上查找成功/不成功的平均查找数\***

- KMP（选+算+应）

> KMP算法的核心是next[]数组，掌握**计算机的next[]数组，**这里说的计算机的next[]数组是相当于手动模拟的next[]数组而言的，408考察的是计算机的next[]数组
> 计算机next[] = 手动模拟的next[] **右移一位 + 1**
> **KMP算法记下来，注意KMP的特点是主串不回溯**

### 2.7 排序

- 插入排序（选）

> \1. 直接插入排序
> \2. 折半插入排序：引入二分思想
> \3. [希尔排序](https://www.zhihu.com/search?q=希尔排序&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A165229143})

- 交换排序（选+算）

> \1. 冒泡排序
> **2. 快速排序：把Partition函数当模板记下来**

- 选择排序（选）

> \1. 简单选择排序
> \2. 堆排序：向下调整 、向上调整
> （1）堆的构建：向下调整，这里的时间复杂度为O(n)要知道为什么
> （2）堆排序：向下调整

- 归并排序（选+算）

> 掌握Merge函数，当模板记下来

- 基数排序（选+算）

> 基数排序是给予非比较的排序
> 拓展：桶排序、计数排序

- 外部排序--多路归并排序（选）

> \1. 败者树：要会自己构建败者树，败者树可以减少比较次数
> \2. 置换-选择排序：划分初试归并段
> \3. 最佳归并树：减少归并过程中的I/O次数
> **注意：虽然外部排序的内容少，但是外部排序的难度比内部排序的难度要高，幸运的是外部排序基本以选择题形式考察；学习外部排序重点是学习思想，要去真正的理解它。**

------

## 3. 经验总结

1. 在408真题中的数据结构部分的题目可以看出：选择题大多考察相应结构/算法的中间过程，这就要求我们必须深刻的理解和熟练的掌握此结构/算法，能从计算机的角度出发去思考计算机处理这个问题处理的整个过程是什么样的，而不要从个人主观上出发去看此结构/算法，因为这样只是表面上搞懂了此结构/算法，但是一做题该错的还是错，不会的还是不会；大题部分重点在于积累和做题，因为408真题中算法大题和应用大题基本上每一年考察的知识点和思想都不是很相同，所有我们需要多去做大题，虽然大题比较难做，但是一点要坚持去把王道的课后大题都做完，一边做一边去思考，慢慢的就会变好。
2. 选择题经常有很多坑，做题不要想当然，写答案前多问问自己这题真的是这样？真的这麽简单？比别人想的更多才能比别人走的更远；大题主要强调的是思想，多去想想算法大题有什么其他的解法，应用大题考的知识点是哪些，一定要做到看完题目心中有数，方能不乱阵脚。





# 题目

